#include <cstddef>
#include <err.h>
#include <fstream>
#include <iostream>
#include <seccomp.h>
#include <stdio.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/utsname.h>
#include <unistd.h>

static void sandbox(void) {
  // clang-format off

  // While just banning dangerous syscalls could be much better for mantaining this library, I don't trust that I would be able to comprehensively list them
  // This list was generated by looking at the emitted syscalls from godot

  // Maybe would could limit this more? Surely some of these are used but not absoloutely required.
  const char *permitted_syscalls[] = {
    "openat",
    "read",
    "close",
    "exit_group",
    "uname",
    "newfstatat",
    "openat",
    "wait4",
    "ioctl",
    "execve",
    "brk",
    "arch_prctl",
    "access",
    "mmap",
    "pread64",
    "set_tid_address",
    "set_robust_list",
    "rseq",
    "mprotect",
    "prlimit64",
    "munmap",
    "getrandom",
    "futex",
    "readlink",
    "getdents64",
    "fstatfs",
    "fadvise64",
    "getcwd",
    "rt_sigaction",
    "pipe2",
    "rt_sigprocmask",
    "clone3",
    "fcntl",
    "lseek",
    "chdir",
    "geteuid",
    "getegid",
    "getuid",
    "getgid",
    "socket",
    "connect",
    "getpeername",
    "getsockname",
    "poll",
    "writev",
    "recvfrom",
    "recvmsg",
    "clone",
    "getpid",
    "mremap",
    "fstat",
    "sched_get_priority_max",
    "sched_get_priority_min",
    "statfs",
    "gettid",
    "sched_getaffinity",
    "socketpair",
    "sendmsg",
    "stat",
    "unlink",
    "symlink",
    "prctl",
    "getresuid",
    "getresgid",
    "sendto",
    "sched_yield",
    "memfd_create",
    "ftruncate",
    "fallocate",
    "umask",
    "mkdir",
    "setsockopt",
    "getsockopt",
    "ppoll",
    "rmdir",
    "bind",
    "clone3",
    "wait4",
    "arch_prctl",
    "sched_setaffinity",
    "sysinfo",
    "write",
  };
  // clang-format on

  // Block ALL syscalls, we will punch holes in this.
  // ERRNO 1 seems to allow the process to continue, even if the syscall fails.

  // uint action = SCMP_ACT_LOG;
  // uint action = SCMP_ACT_ERRNO(1);
  uint action = SCMP_ACT_KILL;

  scmp_filter_ctx seccomp_ctx = seccomp_init(action);
  if (!seccomp_ctx)
    err(1, "seccomp_init failed");

  // Punch holes for every syscall we need.
  for (int i = 0;
       i < sizeof(permitted_syscalls) / sizeof(permitted_syscalls[0]); i++) {
    const char *syscall = permitted_syscalls[i];
    if (seccomp_rule_add_exact(seccomp_ctx, SCMP_ACT_ALLOW,
                               seccomp_syscall_resolve_name(syscall), 0)) {
      perror("seccomp_rule_add_exact failed");
      exit(1);
    }
  }

  /* apply the composed filter */
  if (seccomp_load(seccomp_ctx)) {
    perror("seccomp_load failed");
    exit(1);
  }

  /* release allocated context */
  seccomp_release(seccomp_ctx);

  if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == -1)
    err(0, "PR_SET_NO_NEW_PRIVS failed");
}

int main(int argc, char *argv[]) {
  sandbox();

  char *program_path = argv[1];
  for (int i = 1; i < argc - 2; ++i) {
    argv[i] = argv[i + 2];
  }
  execv(program_path, argv);

  return 0;
}
